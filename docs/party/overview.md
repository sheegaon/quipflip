# Quipflip Party Mode: Architecture Overview
This document provides a high-level overview of the architecture and design of the Quipflip Party Mode backend. It covers the core data models, session lifecycle, in-game phase management, progress tracking, AI player integration, WebSocket communication, and cleanup strategies.

## 1. Core data model (where `PartyParticipant` fits)

### PartySession

`PartySession` is the “room” object: one party lobby + game config. It stores:

* `session_id` (UUID PK)
* `party_code` — short 8-char join code users type in
* `host_player_id`
* config: `min_players`, `max_players`, `prompts_per_player`, `copies_per_player`, `votes_per_player`
* lifecycle: `status` (`OPEN`, `IN_PROGRESS`, `COMPLETED`), `current_phase` (`LOBBY`, `PROMPT`, `COPY`, `VOTE`, `RESULTS`, then `COMPLETED`), timestamps (`created_at`, `started_at`, `completed_at`, `phase_started_at`, `locked_at`)

`create_session` sets:

* `current_phase='LOBBY'`, `status='OPEN'`, `created_at=now`.

### PartyParticipant

Each combination of session + player is a `PartyParticipant`:

* `participant_id`
* `session_id` FK → PartySession
* `player_id` FK → QFPlayer
* `is_host`, `status` (`JOINED`, `READY`, `ACTIVE`, `COMPLETED`, `DISCONNECTED`)
* Counters: `prompts_submitted`, `copies_submitted`, `votes_submitted`
* Presence / timing: `joined_at`, `ready_at`, `last_activity_at`, `connection_status` (`connected` / `disconnected`)

These counters are the **core of progress tracking** in each phase — you can literally see the game logic manipulating these fields.

### PartyRound

`PartyRound` associates the party with a specific Quipflip `Round` record (the existing game logic):

* `party_round_id` (UUID PK)
* `session_id`
* `round_id` (FK → main `Round`)
* `phase_type` (`PROMPT`, `COPY`, `VOTE`)
* `player_id` (who owns this party round)
* `phraseset_id` (for copy/vote linkage)
* timestamps, etc.

So you’re **reusing the existing single-round engine** (through `Round`) and just layering party coordination on top via `PartyRound`.

### PartyPhraseset

`PartyPhraseset` links the phrasesets generated by prompt/copy rounds to the party session:

* `party_phraseset_id`
* `session_id`
* `phraseset_id` (FK → main `Phraseset`)
* flags like `available_for_voting`, tracking which sets are in the voting pool.

When the game moves to VOTE phase, **all party phrasesets are flipped to `available_for_voting=True`**.

---

## 2. Lobby lifecycle (before the game actually starts)

### 2.1 Creating a party session

Endpoint: `POST /party/create` → `create_party_session`

Flow:

1. Authenticated player is resolved as `QFPlayer` (the host).

2. `PartySessionService.create_session(...)` is called with config from `CreatePartySessionRequest`.

3. `create_session`:

   * Ensures the host is **not already in another active session** (`get_active_session_for_player`).
   * Generates a **unique 8-character code** (letters+digits) via `_generate_unique_party_code`.
   * Creates the `PartySession` row with `status='OPEN'`, `current_phase='LOBBY'`.
   * Adds the host as a `PartyParticipant` with `status='READY'`, `is_host=True` and timestamps set to now.

4. Commit and refresh the session.

5. The API then calls `get_session_status` and returns a `CreatePartySessionResponse` including the participants list and config.

### 2.2 Listing parties to join

Endpoint: `GET /party/list` → `PartySessionService.list_active_parties()`

`list_active_parties()`:

* Builds a subquery `participant_counts` to count participants per session.
* Another subquery `human_participant_counts` that joins `QFPlayer` and filters out AI emails (ending in `AI_PLAYER_EMAIL_DOMAIN`).
* Returns only sessions:

  * `status == 'OPEN'`
  * `participant_count < max_players`
  * at least 1 **human** participant
  * ordered by `created_at DESC`

Result is converted to `PartyListItemResponse` objects for the frontend lobby list.

### 2.3 Joining a party

Endpoints:

* `POST /party/join` (by `party_code`)
* `POST /party/{session_id}/join` (by direct ID)

Both call `_handle_party_join()`:

1. Check if the player is **already a participant** in that session via `get_participant`.

2. If not, call `PartySessionService.add_participant(...)`:

   * Validates session exists and is `OPEN`, not started.
   * Checks participant count vs `max_players`.
   * Ensures player is not already in this session and not active in another session.
   * Creates a `PartyParticipant` with `status='READY'` (so new joiners default to ready).

3. Then `get_session_status` is called to rebuild a complete view.

4. If it’s a fresh join (new participant): `PartyWebSocketManager.notify_player_joined` sends a WebSocket event to everyone in that session with player ID, username, and the new participant count.

Exceptions (`SessionAlreadyStartedError`, `SessionFullError`, etc.) are mapped to HTTP 400/409 responses.

### 2.4 Marking ready

Endpoint: `POST /party/{session_id}/ready` → `PartySessionService.mark_participant_ready`

`mark_participant_ready`:

* Asserts session exists and is still `OPEN`.
* Fetches participant; if missing, raises a generic `PartyModeError`.
* Sets `status='READY'`, `ready_at=now`, commits.

The router then:

* Recomputes lobby readiness counts (ready vs total) to decide `can_start` flag for the host UI.
* Uses `ws_manager` to broadcast updated ready counts / presence so the lobby UI reflects who is ready. (You can see similar patterns in other websocket notifications; the ready notification uses the same manager.)

### 2.5 Adding AI players

Endpoint: `POST /party/{session_id}/add_ai` → `PartySessionService.add_ai_player`

`add_ai_player`:

* Verifies session exists.
* Verifies caller is host (`get_participant` and `is_host`).
* Checks session is still `OPEN` and not full.
* Computes the pool of AI players already active in open/in-progress sessions (to reuse AI accounts but keep them from being double-booked).
* Uses `AIService.get_or_create_ai_player(AIPlayerType.QF_PARTY, excluded=active_pool_players)` to either grab or create an AI QFPlayer for this party.
* Creates `PartyParticipant` for that AI player, with `status='READY'` and `is_host=False`.
* Commits and optionally triggers websocket updates that a new (AI) player joined.

### 2.6 Starting the session

Endpoint: `POST /party/{session_id}/start` → `PartySessionService.start_session`

`start_session`:

* Verifies session exists and `status == 'OPEN'`.

* Validates requesting player is the host (`get_participant` with `is_host=True`).

* Checks `participant_count >= min_players`.

* Sets:

  * `status = 'IN_PROGRESS'`
  * `current_phase = 'PROMPT'`
  * `started_at = now`
  * `locked_at = now` (used for concurrency/protection)
  * `phase_started_at = now`

* Bulk-updates all participants to `status='ACTIVE'`.

The API then sends a `session_started` websocket event via `PartyWebSocketManager`, so clients leave the lobby UI and move into the prompt phase UI.

---

## 3. In-game lifecycle: phases and submissions

Phase progression is linear:

> `LOBBY → PROMPT → COPY → VOTE → RESULTS → COMPLETED`

That is handled by `PartySessionService.advance_phase` and `advance_phase_atomic`.

### 3.1 High-level coordination: PartyCoordinationService

`PartyCoordinationService` orchestrates **per-phase** actions and integrates with:

* Round engine (prompt/copy/vote)
* Phraseset creation
* Queue
* Transactions (entry costs / payouts)
* AIService for AI submissions
* `PartySessionService` for linking rounds & progress tracking
* `PartyWebSocketManager` for realtime updates

It exposes methods like:

* `start_party_prompt_round`
* `submit_party_prompt`
* `start_party_copy_round`
* `submit_party_copy`
* `start_party_vote_round`
* `submit_party_vote`
* Private helper `_trigger_ai_submissions_for_new_phase` etc.

Let’s walk each phase.

---

### 3.2 PROMPT phase

**Start a prompt round**

Endpoint: `POST /party/{session_id}/round/prompt/start` → `PartyCoordinationService.start_party_prompt_round`

Key logic:

1. Fetch party session (`get_session_by_id`) and validate:

   * `status == 'IN_PROGRESS'`
   * `current_phase == 'PROMPT'` (otherwise `WrongPhaseError`)

2. Get `PartyParticipant` for this player; ensure `status == 'ACTIVE'` and they haven’t already submitted all required prompts (`prompts_submitted < prompts_per_player`), otherwise `AlreadySubmittedError`.

3. Use the normal Quipflip **prompt-round engine** (single-player logic) to:

   * Pick or allocate a prompt.
   * Create a `Round` object with game type `GameType.QF_PARTY` so these rounds are stamped as party-mode.
   * Possibly charge an entry cost via `TransactionService` (if party games have entry fees).

4. Call `PartySessionService.link_round_to_party` with:

   * `session_id`, `round_id`, `phase_type='PROMPT'`, `player_id` etc.
   * That creates a `PartyRound` record.

**Submitting a prompt**

Endpoint: `POST /party/{session_id}/round/prompt/{round_id}/submit` → `submit_party_prompt`

Flow:

1. Validate session is in `PROMPT` phase and round belongs to this party and player (by checking PartyRound + Round).

2. Validate the prompt phrase string (`InvalidPhraseError` if fails).

3. Call the regular `RoundService.submit_prompt` to write the phrase into the `Phraseset` for this round.

4. Link created `Phraseset` to party via `PartySessionService.link_phraseset_to_party` (creating a `PartyPhraseset` record for later copy/vote phases).

5. Call `PartySessionService.increment_participant_progress` with `phase_type='PROMPT'`, which:

   * Increments `prompts_submitted` on that participant.
   * Updates `last_activity_at`.

6. Send WebSocket progress update via `ws_manager.notify_player_progress`, including the new per-session `progress` object and participants state.

7. Check if **all active participants** are done with prompts via `PartySessionService.can_advance_phase`.

8. If yes, call `advance_phase_atomic(session_id)`:

   * Uses a distributed lock (`lock_client.lock("advance_phase:session_id")`) to avoid races between players / AI finishing at roughly the same time.
   * If `can_advance_phase` is still true inside lock, calls `advance_phase` to transition `current_phase` to `COPY`, sets `phase_started_at`, logs.

9. `PartyWebSocketManager.notify_phase_transition` is called so clients switch UI to COPY phase.

10. `_trigger_ai_submissions_for_new_phase` is invoked to have AI participants automatically proceed through COPY or VOTE phase as needed (details below).

---

### 3.3 COPY phase

**Start a copy round**

Endpoint: `POST /party/{session_id}/round/copy/start` → `start_party_copy_round`

Flow differences vs PROMPT:

1. Checks `current_phase == 'COPY'`.

2. Uses `PartyPhraseset` to identify **which phrasesets this player can still copy**:

   * Must not be their own prompts.
   * Must not be ones they’ve already copied (tracked via `PartyRound` / `phraseset_id` associations).
   * Must be `available_for_voting` (or pre-marked as eligible for copy).

3. As with prompts, uses round engine to start a copy round bound to a given `phraseset_id`, again with `GameType.QF_PARTY`.

4. Creates a `PartyRound` record with `phase_type='COPY'`, `phraseset_id` set.

**Submitting a copy**

Endpoint: `POST /party/{session_id}/round/copy/{round_id}/submit`:

* Validates not already submitted all required copies per `copies_per_player`.
* Calls the normal copy-submission logic (record phrase, build phraseset).
* Links phraseset if needed.
* Calls `increment_participant_progress` with `phase_type='COPY'` to increment `copies_submitted`.
* Broadcasts progress via WebSocket.
* If `can_advance_phase` returns true, uses `advance_phase_atomic` to move to VOTE.

---

### 3.4 VOTE phase

When `advance_phase` moves from `COPY → VOTE`, it calls `_mark_phrasesets_available_for_voting`, flipping all `PartyPhraseset.available_for_voting=True`.

**Start a vote round**

Endpoint: `POST /party/{session_id}/round/vote/start` → `start_party_vote_round`

Key logic:

1. Ensure `current_phase == 'VOTE'`.

2. Find an eligible `PartyPhraseset` for this player to vote on:

   * Not created by them (so they don’t vote on their own prompt/copy).
   * Not already voted on by them (tracked again via Round/PartyRound).
   * `available_for_voting == True`.

3. If none available, but they still haven’t reached `votes_per_player`, you might allocate fallback phrasesets (e.g. from queue / non-party content).

4. Start a vote round for that phraseset using the main round engine.

5. Create a `PartyRound` entry with `phase_type='VOTE'`.

**Submitting a vote**

Endpoint: `POST /party/{session_id}/round/vote/{round_id}/submit`:

* Validates the round and player.
* Calls the standard vote-submission logic (persist vote, update scoring).
* Calls `increment_participant_progress` with `phase_type='VOTE'` → increments `votes_submitted`.
* Broadcasts progress and, if everyone is done, `advance_phase_atomic` moves to `RESULTS`.

---

### 3.5 RESULTS phase and completion

`advance_phase` chain: `VOTE → RESULTS → COMPLETED`. The first transition sets `current_phase='RESULTS'`; the second (after some explicit call to “finish” or background scoring) sets `status='COMPLETED'` and `completed_at`.

---

## 4. Tracking progress (how those participant fields get used)

### PartySessionService.get_session_status

This is the **central view** of state returned in `PartySessionStatusResponse` and used by almost all endpoints.

It does roughly:

1. Fetch `PartySession` and all its `PartyParticipant` joined with `QFPlayer` for usernames and AI detection.

2. Build a `participants` list of `PartyParticipantResponse`:

   * For each participant:

     * `prompts_submitted`, `copies_submitted`, `votes_submitted` directly from DB.
     * `prompts_required = session.prompts_per_player` etc.

3. Compute `progress` totals:

   * `total_prompts = sum(p.prompts_submitted)`, `total_copies`, `total_votes`.
   * `required_prompts = prompts_per_player * active_player_count`, etc.
   * `players_ready_for_next_phase` = count of players whose `*_submitted >= required` for current phase.
   * `total_players` = number of active participants.

This is the object that drives all those little progress bars and “X of Y done” indicators on the frontend.

### can_advance_phase

It uses `current_phase` and compares `prompts_submitted` / `copies_submitted` / `votes_submitted` to the per-player required counts for **active** participants only:

* In PROMPT: `p.prompts_submitted >= session.prompts_per_player` for all active participants, etc.

### increment_participant_progress

This is the **single entry point** that actually bumps counters:

* Looks up `PartyParticipant` for `(session_id, player_id)`.
* Based on `phase_type`, increments `prompts_submitted`, `copies_submitted`, or `votes_submitted`.
* Updates `last_activity_at`, commits.

Everything else is orchestrated around this.

---

## 5. AI players and automatic submissions

AI players are just `QFPlayer`s whose email ends with `AI_PLAYER_EMAIL_DOMAIN` (e.g. `@ai.quipflip`). `_is_ai_player` encapsulates this.

When a new phase begins (once humans have finished), `PartyCoordinationService._trigger_ai_submissions_for_new_phase` kicks in:

* It finds AI `PartyParticipant`s in that session.

* For each AI participant, it uses a **retry with exponential backoff** helper (`retry_with_backoff`) to handle lock timeouts:

  * Each AI submission may involve DB locks / queue locks, especially when many AI players act simultaneously.
  * If it sees a lock timeout, it logs a warning and retries after a randomized jitter delay (0.1s × 2^attempt).

* For PROMPT/COPY/VOTE, it effectively calls the same `start_party_*` + `submit_party_*` flows but with AI text coming from `AIService`:

  * `AIService.generate_prompt(...)` / `generate_copy(...)` / `generate_vote(...)` depending on the phase and on the AI type (`AIPlayerType.QF_PARTY`).

The important bit: **AI logic is layered on top of the same party API**, not a separate path, which keeps invariants shared between human and AI flows.

---

## 6. WebSockets and presence (PartyWebSocketManager)

`PartyWebSocketManager` is a dedicated manager for party-mode WebSockets. It’s used by the party router, not the general notification manager.

Key responsibilities:

* Track open WebSocket connections per `session_id`.
* Update `PartyParticipant.connection_status` and `last_activity_at` on connect/disconnect.
* Broadcast structured JSON messages to all sockets in a session.

### connect / disconnect

* When a client opens a WebSocket to `/party/{session_id}/ws`, the manager:

  * Adds the socket to an internal map keyed by `session_id`.
  * Marks their participant record as `connection_status='connected'`, `last_activity_at=now`.

* On disconnect:

  * Sets `connection_status='disconnected'`.
  * Updates `last_activity_at`.
  * Triggers possible removal if they stay disconnected more than 5 minutes (handled by `remove_inactive_participants`).

### Notifications

Manager has methods like:

* `notify_player_joined(session_id, player_id, username, participant_count)` — broadcast when new player joins.
* `notify_session_started(session_id)` — when host starts the session.
* `notify_phase_transition(session_id, new_phase)` — when phase changes.
* `notify_player_progress(session_id, progress)` — on each submission, with the updated `PartySessionStatusResponse`.
* `notify_player_ready`, `notify_player_left`, `notify_presence_changed` for lobby UI.

The payloads include type fields (`"event": "player_joined"`, etc.) so the frontend can switch on them.

---

## 7. Cleanup and edge cases

### Removing inactive participants

`PartySessionService.remove_inactive_participants(session_id)`:

* Finds participants with:

  * `connection_status='disconnected'`
  * `last_activity_at` older than 5 minutes.

* Removes them in batch and logs.

* For each removed participant **who was host**, it calls `_reassign_host`:

  * Prefers a human participant as new host, otherwise uses first AI.

* After removals, if **no human participants remain**:

  * Deletes the entire `PartySession` via `_delete_empty_session`, which cascades `PartyParticipant`, `PartyRound`, `PartyPhraseset`.

`cleanup_inactive_sessions` iterates across all `OPEN` sessions and calls `remove_inactive_participants` for each, returning some stats.

---

## 8. Putting it all together

From a backend-architecture POV:

* **Models** define the party game domain: session config & lifecycle, participants with per-phase counters, party-specific round links, and phraseset links.
* **PartySessionService** is your stateful session manager: create, join, ready, start, progress checks, phase transitions, host reassignment, inactivity cleanup.
* **PartyCoordinationService** sits on top, gluing the existing Quipflip core game (Round/Phraseset/Transactions/Queue) into party phases, and handling AI players + phase transitions.
* **PartyWebSocketManager** provides realtime updates so clients see lobby changes and in-game progress without polling.
* **PartyScoringService** (which we didn’t dwell on here) reads all the rounds, scores, and transactions associated with the session and produces a final scoreboard for the RESULTS view.
