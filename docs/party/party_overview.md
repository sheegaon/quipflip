# Quipflip Party Mode: Architecture Overview

This document explains how the Party Mode pieces fit together:

- How the party-specific tables relate to the core Quipflip data model
- How lobby and in-game phases progress
- How the coordination services use the existing prompt / copy / vote engine
- How WebSockets and cleanup jobs keep sessions healthy

It **does not** try to repeat API contracts or column lists. For those, use:

- [`party_data_models_and_schemas.md`](party_data_models_and_schemas.md) – SQLAlchemy tables + Pydantic schemas
- [`party_api.md`](party_api.md) – all HTTP endpoints, request/response shapes, and error codes

Think of this as the “how it works” narrative layer on top.

---

## 1. Core data model (where `PartyParticipant` fits)

Party Mode sits on top of the normal Quipflip entities (`QFPlayer`, `Round`, `Phraseset`, `Transaction`, etc.) and adds four party-specific tables:

- `PartySession`
- `PartyParticipant`
- `PartyRound`
- `PartyPhraseset`

**Field-by-field definitions live in `party_data_models_and_schemas.md`**. Here we only care about how they’re used together.

### PartySession

`PartySession` is the “room” object: one group of players playing one multi-phase match.

Conceptually, a `PartySession` holds:

- Identity: a `session_id` (UUID) and an 8-character `party_code` players can type in to join
- Ownership: `host_player_id`
- Config: `min_players`, `max_players`, and how many `prompts_per_player`, `copies_per_player`, `votes_per_player`
- Lifecycle: `status` (`OPEN`, `IN_PROGRESS`, `COMPLETED`), `current_phase` (`LOBBY`, `PROMPT`, `COPY`, `VOTE`, `RESULTS`), and timestamps (`created_at`, `started_at`, `completed_at`, `phase_started_at`, `locked_at`)

Relationships:

- One-to-many with **`PartyParticipant`** – everyone in the session (humans + AI)
- One-to-many with **`PartyRound`** – the underlying `Round` records for this match
- One-to-many with **`PartyPhraseset`** – the `Phraseset` records used in the match

See **Party Mode Data Models & Schemas → `PartySession`** for full columns and constraints.

### PartyParticipant

Each player inside a session (human or AI) is represented by a `PartyParticipant`.

Key ideas:

- Identified by `(session_id, player_id)` and a `participant_id` PK
- Tracks **role/state**: `is_host`, plus `status` values such as `JOINED`, `READY`, `ACTIVE`, `COMPLETED`, `DISCONNECTED`
- Tracks **progress counters**: `prompts_submitted`, `copies_submitted`, `votes_submitted`
- Tracks **presence/timing**: `joined_at`, `ready_at`, `last_activity_at`, `connection_status` (`connected` / `disconnected`)

These counters and flags are what the services use to answer questions like:

- “Is everyone ready in the lobby?”
- “Has this player finished all prompts for the PROMPT phase?”
- “Can we advance to the next phase?”

See **`PartyParticipant`** in `party_data_models_and_schemas.md` for exact fields and indexes.

### PartyRound

`PartyRound` links Party Mode to the existing single-round engine.

For every prompt / copy / vote round started inside a party, you still create a normal `Round` row. `PartyRound` adds:

- `session_id` – which party this round belongs to
- `round_id` – FK to the core `Round`
- `phase_type` – `PROMPT`, `COPY`, or `VOTE`
- `player_id` – who owns this party round
- `phraseset_id` – link into the `Phraseset` generated by the usual QF pipeline (for copy/vote)

This lets you:

- Reuse the existing game logic and scoring
- Still know “which party” each round belongs to
- Still know “which phase/player” a given `Round` was part of in the match

See **`PartyRound`** in `party_data_models_and_schemas.md` for the full schema.

### PartyPhraseset

`PartyPhraseset` links the `Phraseset` records created by the prompt/copy/vote pipeline back to the party session.

Conceptually it tracks:

- Which party a `Phraseset` came from (`session_id`, `phraseset_id`)
- Whether it’s currently **eligible for voting** in this party (`available_for_voting`, etc.)
- Any per-session metadata needed for the final results and awards

When the game moves to the VOTE phase, all `PartyPhraseset`s for the session are marked available for voting and become the pool used by the party’s vote rounds.

See **`PartyPhraseset`** in `party_data_models_and_schemas.md` for full details.

---

## 2. Lobby lifecycle (before the game actually starts)

The lobby covers everything from “host clicks Create Party” up to “host clicks Start Game”.

All the HTTP surfaces for this section are documented in:

- **`party_api.md`**
  - *Session Discovery & Creation* (list and create)
  - *Lobby Management* (join/leave/ready/AI/ping/start)

This section is about **what those endpoints do internally** in terms of services and data.

### 2.1 Creating a party session

Backed by `POST /party/create` (see *Create a new party session* in `party_api.md`).

Internally, `PartySessionService.create_session`:

- Checks the host is **not already in another active party** (via something like `get_active_session_for_player`)
- Generates a **unique 8-char `party_code`**
- Creates a `PartySession` row with:
  - `current_phase = 'LOBBY'`
  - `status = 'OPEN'`
  - config copied from `CreatePartySessionRequest`
- Creates an initial `PartyParticipant` row for the host
  - Host is marked as `is_host=True`, status `JOINED` (or auto-`READY`, depending on the config)

The API wraps this into a `CreatePartySessionResponse` (see schemas in `party_data_models_and_schemas.md`).

### 2.2 Listing parties to join

Backed by `GET /party/list` (see *List active parties* in `party_api.md`).

Internally, the service:

- Returns only sessions that:
  - Have `status == 'OPEN'`
  - Have `participant_count < max_players`
  - Have at least one **human** participant (no “AI-only” lobbies)
- Orders results by `created_at DESC`
- Maps each row into a `PartyListItemResponse` with:
  - Basic config (min/max players, code)
  - Current occupancy and host info

The frontend renders this as the “public lobby listing” to join from.

### 2.3 Joining a party

Backed by `POST /party/join` (join by code) and `POST /party/{session_id}/join` (join by id). See *Join party by code / Join party by session ID* in `party_api.md`.

Internally, `PartySessionService.join_session` (or equivalent):

- Validates the session exists and is still `OPEN`
- Ensures the joining player is not already in another active session
- Checks `participant_count < max_players`
- Creates or reuses a `PartyParticipant` row for `(session_id, player_id)` with:
  - Initial `status='JOINED'`
  - Presence fields (`joined_at`, `last_activity_at`) set to `now`
- Returns the current `PartySessionStatusResponse` so the client can immediately render the lobby
- Triggers a WebSocket notification (see section 6) so existing players see the new participant

### 2.4 Marking ready

Backed by `POST /party/{session_id}/ready` (see *Mark player ready* in `party_api.md`).

The service:

- Validates session is `OPEN`
- Checks the caller is a `PartyParticipant` in that `session_id`
- Flips their `status` to `READY` and stamps `ready_at = now`
- Recomputes lobby readiness (e.g., number of READY vs total ACTIVE players) and computes a `can_start` flag for the host
- Broadcasts the updated lobby state via WebSocket

The exact response and booleans are defined in `PartySessionProgressResponse` / `PartyParticipantResponse` in `party_data_models_and_schemas.md`.

### 2.5 Adding AI players

Backed by `POST /party/{session_id}/add_ai` (see *Add an AI player (host only)* in `party_api.md`).

`PartySessionService.add_ai_player` (plus `AIService`) is responsible for:

- Validating:
  - Session exists and is `OPEN`
  - Caller is the host for that session
  - Session is not full (`participant_count < max_players`)
- Picking an AI QF account:
  - Reusing existing AI accounts where possible
  - Avoiding double-booking the same AI into two active sessions
- Creating a `PartyParticipant` row for that AI with:
  - `is_ai = True`
  - `status = 'READY'` (AI players don’t need a separate “ready” button)
- Emitting WebSocket updates so the lobby UI shows the AI entry

AI behavior (when they auto-submit prompts/copies/votes) is covered later in section 5.

### 2.6 Starting the session

Backed by `POST /party/{session_id}/start` (see *Start party session (host only)* in `party_api.md`).

`PartySessionService.start_session`:

- Validates:
  - Session exists
  - `status == 'OPEN'`
  - Caller is the host
  - `participant_count >= min_players`
- Transitions session:

  - `status = 'IN_PROGRESS'`
  - `current_phase = 'PROMPT'`
  - `started_at = now`
  - `phase_started_at = now`
  - `locked_at = now` (used by some operations to guard against concurrent phase changes)

- Bulk updates all participants to **`status = 'ACTIVE'`** so they are ready to start submitting prompts
- Sends a WebSocket `session_started` (or equivalent) event so clients move to the PROMPT UI

From this point on, the main in-game lifecycle and progress tracking take over.

---

## 3. In-game lifecycle: phases and submissions

Once the game starts, phase progression is linear:

> `LOBBY → PROMPT → COPY → VOTE → RESULTS → COMPLETED`

All of the HTTP endpoints for these phases live under:

- *Starting Party Rounds (Prompt / Copy / Vote)* in `party_api.md`
- *Session Status & Results* in `party_api.md`

**Frontend flow note:** the in-game UI polls `GET /party/{session_id}/status` to detect phase changes and then calls the appropriate `POST /party/{session_id}/rounds/{phase}` endpoint to start the next round. WebSockets only inform the UI about progress counters; they do not drive phase transitions.

This section focuses on how the **services and models** work together.

### 3.1 High-level coordination: `PartyCoordinationService`

`PartyCoordinationService` is the main orchestrator for in-game phases. It:

- Knows how to **start** a party round for a player:
  - Calls the existing single-round APIs / services to create a `Round`
  - Writes a corresponding `PartyRound` row (`phase_type`, `player_id`, etc.)
- Knows how to **submit** a prompt / copy / vote:
  - Calls the underlying prompt/copy/vote submission logic (validation, scoring, phraseset creation)
  - Uses `PartySessionService.increment_participant_progress` to bump per-phase counters
- Decides when the session can **advance** to the next phase:
  - Uses `PartySessionService.can_advance_phase`
  - Calls `PartySessionService.advance_phase_atomic` to flip the phase and timestamps safely

### 3.2 PROMPT phase

**Start prompt rounds**

Backed by `POST /party/{session_id}/round/prompt/start` (see `party_api.md`).

Flow (conceptually):

1. Validate:

   - Session exists
   - `status == 'IN_PROGRESS'`
   - `current_phase == 'PROMPT'`
   - Caller is an `ACTIVE` participant who hasn’t finished their required prompts

2. Start a normal Quipflip **prompt** round:

   - Create a `Round` with the right `GameType` (party-mode variant)
   - Charge any entry fees using the existing `TransactionService` (if configured)

3. Insert a `PartyRound` link for this `(session_id, round_id, phase_type='PROMPT', player_id)`

**Submit prompt**

Backed by the usual “submit prompt” party endpoint (see `party_api.md`).

- Submission goes through the **existing prompt validation and persistence**
- Once the underlying `Round` is submitted successfully:
  - `PartySessionService.increment_participant_progress(phase_type='PROMPT')` bumps `prompts_submitted` for that participant
  - A WebSocket event broadcasts updated progress
- If all active participants have `prompts_submitted >= prompts_required`, `PartySessionService.can_advance_phase` returns `True` and `advance_phase_atomic` moves the session to `current_phase = 'COPY'`

### 3.3 COPY phase

The COPY phase uses the normal copy-round engine plus `PartyRound` / `PartyPhraseset` links.

High-level behavior:

- Starting a copy round:
  - Validates `current_phase == 'COPY'`
  - Uses existing copy logic to:
    - Select a `Phraseset` or prompt to copy
    - Create the copy `Round`
  - Creates a `PartyRound` entry for `(session_id, round_id, 'COPY', player_id)`
- Submitting a copy:
  - Reuses the existing submission pipeline (`duplicate_phrase` checks, dictionary validation, etc.)
  - Once successful:
    - Updates the underlying `Phraseset` via core logic
    - Calls `increment_participant_progress(phase_type='COPY')`
    - Sends progress WebSocket updates
  - When everyone has submitted all required copies, `can_advance_phase` moves the session to `VOTE`

Where a prompt/copy set produces a new `Phraseset`, `PartySessionService` creates a `PartyPhraseset` row for later use in the VOTE & RESULTS phases.

### 3.4 VOTE phase

In the VOTE phase, you’re mostly reusing the normal “start vote” and “submit vote” flows, but constrained to the `PartyPhraseset`s for that session.

Key points:

- When transitioning to VOTE, **all `PartyPhraseset`s in the session are marked available for voting**
- Starting a vote round:
  - Validates `current_phase == 'VOTE'`
  - Picks a `PartyPhraseset` that:
    - Belongs to this session
    - Is flagged as available for voting
    - Obeys any “don’t vote on your own phraseset” rules
  - Calls the normal “start vote round” logic to create a `Round`, then writes a `PartyRound` entry
- Submitting a vote:
  - Uses the existing vote submission logic (tracks correctness, payouts, etc.)
  - Calls `increment_participant_progress(phase_type='VOTE')`
  - Broadcasts progress
  - Once all active participants have cast their required votes, `advance_phase_atomic` moves to RESULTS

### 3.5 RESULTS phase and completion

Once voting is done, the session moves through `RESULTS` → `COMPLETED`.

Rough behavior:

- `PartyScoringService` (or equivalent) reads:
  - All `PartyPhraseset`s for the session
  - Underlying `Phraseset` vote counts and payouts
  - Per-player contributions (from `PartyRound` and `PartyParticipant`)
- It computes:
  - Per-player stats: prompts, copies, votes, correctness, total earnings
  - Awards / achievements per match
  - A final scoreboard ordered by whichever ranking metric you choose
- Session state:
  - `current_phase = 'RESULTS'` while results are being generated / displayed
  - Eventually `status = 'COMPLETED'` and `completed_at` is set

The HTTP contract for fetching results is documented under *Get party results* in `party_api.md`, with response schemas in `party_data_models_and_schemas.md` (`PartyResultsResponse`, `PartyPlayerStatsResponse`, etc.).

---

## 4. Tracking progress (how those participant fields get used)

Progress tracking is mostly concentrated in three service methods, plus the Pydantic responses documented in `party_data_models_and_schemas.md`.

### `PartySessionService.get_session_status`

This is the **central read model**. Most endpoints either return this directly or embed parts of it.

Internally it:

1. Fetches the `PartySession` and all its `PartyParticipant`s (joined with `QFPlayer` for usernames, avatar, AI flags).
2. For each participant, builds a `PartyParticipantResponse`:

   - Raw counters: `prompts_submitted`, `copies_submitted`, `votes_submitted`
   - Required counts: derived from the session config (`prompts_per_player`, etc.)
   - Status: `JOINED` / `READY` / `ACTIVE` / `COMPLETED` / `DISCONNECTED`
   - Booleans like “has_finished_prompts”, “has_finished_copies”, “has_finished_votes” based on counters vs required

3. Computes high-level progress info:

   - How many players are ready in the lobby
   - Per-phase completion percentages
   - Whether the host may start the game
   - Whether the session is eligible to advance to the next phase

It wraps all of that into a `PartySessionStatusResponse` used by both REST responses and WebSocket pushes.

### `can_advance_phase`

Given a `PartySession` + its participants, this method answers:

> “Is it safe and sensible to move from the current phase to the next?”

Typical rules:

- In PROMPT / COPY / VOTE:
  - All **human** participants who are still `ACTIVE` must have completed their required submissions for that phase
  - AI participants may be allowed to lag slightly, because the AI auto-submission loop (section 5) will catch up
- It may also enforce some sanity thresholds like:
  - “At least N human players ever participated”
  - “Don’t advance if there are zero humans left”

If `can_advance_phase` returns `True`, the coordination layer calls `advance_phase_atomic`.

### `increment_participant_progress`

This helper:

- Increments the relevant counter on `PartyParticipant`:

  - `prompts_submitted`
  - or `copies_submitted`
  - or `votes_submitted`

- Updates `last_activity_at` so presence cleanup knows they’re active
- Optionally recomputes `PartySessionStatusResponse` for return / broadcast

Call sites:

- Prompt/copy/vote **submission** endpoints in `party_api.md`
- Internal AI-submission helpers (section 5)

---

## 5. AI players and automatic submissions

AI players are just `QFPlayer` rows with a special marker (see the general AI docs) plus `PartyParticipant` rows flagged as `is_ai=True` for the session.

The key goals:

- Reuse the **same** Party Mode HTTP and service flows for both humans and AI
- Keep AI work batched and robust under contention

High-level behavior:

- When a new phase starts, `PartyCoordinationService._trigger_ai_submissions_for_new_phase`:

  - Finds all `PartyParticipant`s with `is_ai=True` in that session
  - For each AI participant that still needs work in this phase, schedules submissions with a **retry + exponential backoff** helper to handle DB/queue lock contention

- For PROMPT / COPY / VOTE, the AI path is:

  - Call the appropriate “start party round” flow (same as humans)
  - Get text from `AIService`:

    - e.g. `AIService.generate_prompt(...)`, `generate_copy(...)`, or `generate_vote(...)` depending on phase

  - Call the same “submit party round” flow as humans
  - Let the normal progress counters and WebSocket events fire

In other words, **AI traffic is layered on top of the same Party Mode API and services**. There is no special hidden path; that keeps everything testable and consistent.

The exact AI models, prompts, and metrics are documented in the AI service docs, not here.

---

## 6. WebSockets and presence (`PartyWebSocketManager`)

Party Mode uses a dedicated WebSocket channel for presence and progress notifications; the gameplay itself (starting rounds, advancing phases) is coordinated through REST endpoints and status polling.

The HTTP side of the WebSocket is documented under *Party WebSocket endpoint* in `party_api.md`. This section focuses on what the manager actually does on the notification channel.

### Connect / disconnect

When a client connects:

- The WebSocket is authenticated (e.g. via a short-lived ws token)
- The connection is associated with a `(session_id, player_id)` pair
- `PartyWebSocketManager` keeps an in-memory mapping from session → live connections

On disconnect:

- The manager marks that participant’s `connection_status` as `disconnected`
- Updates `last_activity_at`
- Optionally broadcasts an updated session status so other players see who has dropped

Presence and inactivity thresholds are used later by cleanup (section 7).

### Notifications

Typical WebSocket events include:

- `player_joined` / `player_left`
- `player_ready_changed`
- `session_started`
- `phase_changed`
- `progress_updated` (per-phase counters changing)
- `ai_player_added`
- `results_available`

All of these are just thin wrappers around `PartySessionStatusResponse` and the other schemas defined in `party_data_models_and_schemas.md`. They let the UI update counts or show toasts, but the client still calls REST endpoints to fetch the latest session status and to progress to the next round.

---

## 7. Cleanup and edge cases

Lobby and match sessions shouldn’t live forever. Two helpers keep things tidy: per-session cleanup and global cleanup.

### Removing inactive participants

`PartySessionService.remove_inactive_participants(session_id, now)`:

- Loads the `PartySession` and its participants
- Marks as “inactive” any participant whose:

  - `connection_status = 'disconnected'`, and
  - `last_activity_at` is older than a timeout (e.g. 5 minutes)

- Removes those participants in batch and logs what happened
- If any removed participant was the **host**:

  - Calls `_reassign_host`, preferring:
    - A human participant if any remain
    - Otherwise the first AI participant

- After removal:

  - If **no human participants remain**, deletes the entire `PartySession`
    - Cascades to `PartyParticipant`, `PartyRound`, and `PartyPhraseset` rows

This keeps zombie lobbies and abandoned games from cluttering the DB.

### Global cleanup

`cleanup_inactive_sessions` (run via a background job / cron) scans across all `OPEN` sessions:

- For each, calls `remove_inactive_participants`
- Aggregates stats (how many sessions cleaned, how many participants removed)
- Optionally logs metrics for observability

The exact scheduling (e.g. every minute vs every 5 minutes) is deployment-dependent, not hard-coded in this doc.

---

## 8. Putting it all together

From a backend-architecture standpoint, Party Mode is:

- **Models**

  - `PartySession`, `PartyParticipant`, `PartyRound`, `PartyPhraseset` extend the existing Quipflip schema with:
    - Session config and lifecycle (`status`, `current_phase`, timestamps)
    - Per-player phase counters and presence
    - Party-specific round links
    - Party-specific phraseset links

- **Services**

  - `PartySessionService` – stateful session manager:
    - Creates/destroys sessions
    - Applies lobby rules (ready counts, min/max players)
    - Handles phase transitions (`advance_phase_atomic`)
    - Reassigns host
    - Performs inactivity cleanup

  - `PartyCoordinationService` – sits on top of the core game engine:
    - Starts prompt/copy/vote rounds tied to a party
    - Delegates phrase/vote validation and scoring to existing services
    - Calls into AI services where needed
    - Drives `can_advance_phase` / `advance_phase`

  - `PartyScoringService` – reads `PartyRound`, `PartyPhraseset`, and core game tables to produce per-match scoreboards and awards.

  - `AIService` – (party-aware) wrapper around model calls, but still using the same Party Mode endpoints and services as humans.

- **Realtime layer**

  - `PartyWebSocketManager` – glues `get_session_status` to the clients:
    - Pushes lobby and in-game updates
    - Tracks connection status for presence and cleanup

Taken together:

- `party_data_models_and_schemas.md` tells you **what** is stored and returned.
- `party_api.md` tells you **what HTTP calls exist** and their contracts.
- This overview tells you **how the pieces work together** to run a full Party Mode match: from
